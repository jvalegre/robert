#!/usr/bin/env python

######################################################.
# 	        Testing CURATE with pytest 	             #
######################################################.

import os
import glob
import pytest
import shutil
import subprocess
import pandas as pd
from robert.curate import curate

# saves the working directory
path_tests = os.getcwd() + "/tests"
path_curate = os.getcwd() + "/CURATE"

# CURATE tests
@pytest.mark.parametrize(
    "test_job",
    [
        (
            "categorical"
        ),  # categorical with numbers test
        (
            "nan_fix"
        ),  # test that empty values are replaced by 0s
        (
            "corr_filter_x"
        ),  # test to disable the correlation filter of X
        (
            "corr_filter_y"
        ),  # test to disable the correlation filter of y
        (
            "filter_thres"
        ),  # test to check the thresholds of the correlation filters
        (
            "filter_thres_yaml"
        ),  # test to check the thresholds of the correlation filters with a yaml file  
        (
            "csv_separator"
        ),  # test to check the separator of the CSV file
        (
            "missing_input"
        ),  # test that if the --names, --y or --csv_name options are empty, a prompt pops up and asks for them
        (
            "rfecv"
        ),  # test for the RFECV feature, default
        (
            "standard"
        ),  # standard test  
        (
            "standard_cmd"
        ),  # standard test through command line

    ],
)
def test_CURATE(test_job):

    # leave the folders as they were initially to run a different batch of tests
    if os.path.exists(f"{path_curate}"):
        shutil.rmtree(f"{path_curate}")
        # remove DAT and CSV files generated by CURATE
        dat_files = glob.glob("*.dat")
        for dat_file in dat_files:
            if "CURATE" in dat_file:
                os.remove(dat_file)

    # Create kwargs dictionary for curate function
    curate_kwargs = {
        'discard': ['xtest']
    }

    if test_job != 'missing_input':
        if test_job == 'rfecv':
            csv_name = 'A_randos.csv'
        else:
            csv_name = 'Robert_example.csv'
        
        curate_kwargs.update({
            'y': 'Target_values',
            'csv_name': f"{path_tests}/{csv_name}",
            'names': 'Name'
        })

    if test_job in ["standard","standard_cmd"]:
        def _check_standard():
            # check that the DAT file is created inside the CURATE folder
            assert not os.path.exists("CURATE_data.dat")
            outfile = open(f"{path_curate}/CURATE_data.dat", "r")
            outlines = outfile.readlines()
            outfile.close()
            assert "ROBERT v" in outlines[0]

            # check that descriptors are removed correctly
            model_dict = {
                'RF': {
                    'accepted_vars': ['x10', 'x2', 'x5', 'x7', 'x9'],
                    'discarded_vars': ['Csub-Csub', 'Csub-H', 'H-O', 'x11', 'x8', 'ynoise', 'x4', 'xtest']
                    },
                'GB': {
                    'accepted_vars': ['Csub-Csub', 'Csub-H', 'H-O', 'x10', 'x11', 'x2', 'x5', 'x7', 'x8', 'ynoise'],
                    'discarded_vars': ['x9', 'x4', 'xtest']
                    },
                'NN': {
                    'accepted_vars': ['Csub-Csub', 'Csub-H', 'H-O', 'x10', 'x11', 'x2', 'x5', 'x7', 'x8', 'x9', 'ynoise'],
                    'discarded_vars': ['x4', 'xtest']
                    },
                'MVL': {
                    'accepted_vars': ['Csub-Csub', 'Csub-H', 'H-O', 'x10', 'x11', 'x2', 'x5', 'x7', 'x8', 'x9', 'ynoise'],
                    'discarded_vars': ['x4', 'xtest']
                    },
                    }
            for model in model_dict:
                db_model = pd.read_csv(f"{path_curate}/Robert_example_CURATE_{model}.csv")
                # 1. Duplicate entries are removed
                assert len(db_model['Name']) == 37
                # 2. Correlated variables with X and noise (low R2 with y) are removed
                for var in model_dict[model]['discarded_vars']:
                    assert var not in db_model.columns
                # 3. Ignored variables and y are kept
                assert 'Name' in db_model.columns
                assert 'Target_values' in db_model.columns
                # 4. Discarded variables are removed
                assert 'xtest' not in db_model.columns
                # 5. The rest of the variables are kept
                for var in model_dict[model]['accepted_vars']:
                    assert var in db_model.columns
                assert len(db_model.columns) == len(model_dict[model]['accepted_vars'])+2

                # Check if the descriptors were reduced correctly (less than 1/3 of the data points)
                n_descps = len(db_model.columns) - 2  # subtracting 'Name' and 'Target_values'
                datapoints = len(db_model)
                assert n_descps < (datapoints / 3)

            # check that categorical variables are converted with one-hot encoding
            db_final = pd.read_csv(f"{path_curate}/Robert_example_CURATE.csv")
            categ_vars = ['Csub-H','Csub-Csub','H-O']
            for var in categ_vars:
                assert var in db_final.columns
            assert 'x4' not in db_final.columns
            for val in db_final['Csub-H']:
                assert val in [0,1]

            # check that the CURATE options are stored
            db_save = pd.read_csv(f"{path_curate}/CURATE_options.csv")
            assert db_save['y'][0] == "Target_values"
            assert db_save['ignore'][0] == "['Name']"
            assert 'Robert_example_CURATE.csv' in db_save['csv_name'][0]

            #check that the Pearson heatplot is created
            assert os.path.exists(f'{path_curate}/Pearson_heatmap.png')
        
        # Run the appropriate command
        if test_job == "standard_cmd":
            cmd_robert = [
                "python",
                "-m",
                "robert",
                "--curate",
                "--discard", "['xtest']"
            ]

            cmd_robert = cmd_robert + ['--y','Target_values',
                                    "--csv_name", f"{path_tests}/{csv_name}",
                                    "--names","Name"]
            subprocess.run(cmd_robert)
        else:
            _ = curate(**curate_kwargs)
        
        # Run the checks
        _ = _check_standard()

    elif test_job == "categorical":
        curate_kwargs.update({
            'categorical': 'numbers',
        })
        _ = curate(**curate_kwargs)

        # check if variable x4 was changed
        db_final = pd.read_csv(f"{path_curate}/Robert_example_CURATE.csv")
        assert 'x4' in db_final.columns
        assert 3 in db_final['x4']

    elif test_job == "nan_fix":
        nan_fix_kwargs = {
            'csv_name': f"{path_tests}/Robert_example_NaNs.csv",
            'y': 'Target_values',
            'names': 'Name',
            'discard': ['xtest']
        }

        _ = curate(**nan_fix_kwargs)

        # check that all the missing values were filled
        db_final = pd.read_csv(f"{path_curate}/Robert_example_NaNs_CURATE.csv")
        # 1. Duplicate entries are removed
        assert isinstance(db_final['x2'][4], (int, float))
        assert isinstance(db_final['x2'][0], (int, float))

    elif test_job == 'corr_filter_x':
        corr_filter_x_kwargs = {
            'csv_name': f"{path_tests}/Robert_example.csv",
            'y': 'Target_values',
            'names': 'Name',
            'discard': ['xtest'],
            'corr_filter_x': False
        }
        _ = curate(**corr_filter_x_kwargs)
        
        # check that descriptors aren't removed 
        db_final = pd.read_csv(f"{path_curate}/Robert_example_CURATE.csv")
        discard_vars = ['x1','x3','x5','x6','Csub-O']
        for var in discard_vars:
            assert var in db_final.columns

    elif test_job == 'corr_filter_y':
        corr_filter_y_kwargs = {
            'csv_name': f"{path_tests}/Robert_example.csv",
            'y': 'Target_values',
            'names': 'Name',
            'discard': ['xtest'],
            'corr_filter_y': True
        }
        _ = curate(**corr_filter_y_kwargs)
        
        # check that descriptors aren't removed 
        db_final = pd.read_csv(f"{path_curate}/Robert_example_CURATE.csv")
        assert 'ynoise' not in db_final.columns

    elif test_job in ['filter_thres','filter_thres_yaml']:
        if test_job == 'filter_thres':
            filter_thres_kwargs = {
                'csv_name': f"{path_tests}/Robert_example.csv",
                'y': 'Target_values',
                'names': 'Name',
                'discard': ['xtest'],
                'thres_x': 0.999,
                'corr_filter_y': True,
                'thres_y': 0.000001
            }

        elif test_job == 'filter_thres_yaml':
            filter_thres_kwargs = {
                'varfile': f"{path_tests}/params.yaml",
                'csv_name': f"{path_tests}/Robert_example.csv"
            }
        _ = curate(**filter_thres_kwargs)
        
        # check that descriptors aren't removed
        db_final = pd.read_csv(f"{path_curate}/Robert_example_CURATE.csv")
        # check x threshold
        assert 'x1' in db_final.columns
        # check y threshold
        assert 'ynoise' in db_final.columns

    elif test_job == 'csv_separator':

        # restore original files
        if os.path.exists(f"{path_tests}/Robert_example_separator_original.csv"):
            if os.path.exists(f"{path_tests}/Robert_example_separator.csv"):
                os.remove(f"{path_tests}/Robert_example_separator.csv")
                shutil.move(f"{path_tests}/Robert_example_separator_original.csv",f"{path_tests}/Robert_example_separator.csv")

        # Test to check if the separator of the CSV file is correctly read
        csv_separator_kwargs = {
            'csv_name': f"{path_tests}/Robert_example_separator.csv",
            'y': 'Target_values',
            'names': 'Name',
            'discard': ['xtest']
        }
        _ = curate(**csv_separator_kwargs)

        # check that the DAT file has a warning about the separator
        assert not os.path.exists("CURATE_data.dat")
        outfile = open(f"{path_curate}/CURATE_data.dat", "r")
        outlines = outfile.readlines()
        outfile.close()
        input_found = False
        for line in outlines:
            if "x  WARNING! The original database was not a valid CSV (i.e., formatting issues from Microsoft Excel?)." in line:
                input_found = True
        assert input_found

        # check that the CSV file has the correct separator
        csv_file = pd.read_csv(f"{path_tests}/Robert_example_separator_original.csv", sep=";")
        csv_file_new = pd.read_csv(f"{path_tests}/Robert_example_separator.csv", sep=",")
        assert csv_file.equals(csv_file_new)

        # restore original files
        os.remove(f"{path_tests}/Robert_example_separator.csv")
        shutil.move(f"{path_tests}/Robert_example_separator_original.csv",f"{path_tests}/Robert_example_separator.csv")
    
    elif test_job == 'missing_input':
        # since we're inputting values for input() prompts, we use command lines and provide
        # the answers with external files using "< FILENAME_WITH_ANSWERS" in the command line

        cmd_robert_missing = [
            "python",
            "-m",
            "robert",
            "--curate",
            "--discard", "['xtest']"
        ]

        missing_options = ['csv_name', 'y', 'names']
        for missing_option in missing_options:
            if missing_option == 'csv_name':
                cmd_missing = cmd_robert_missing + ['--y','Target_values',
                                            "--names","Name"]
            elif missing_option == 'y':
                cmd_missing = cmd_robert_missing + ["--csv_name", f"{path_tests}/Robert_example.csv",
                                            "--names","Name"]
            elif missing_option == 'names':
                cmd_missing = cmd_robert_missing + ['--y','Target_values',
                                            "--csv_name", f"{path_tests}/Robert_example.csv"]

            cmd_missing = f'{" ".join(cmd_missing)} < {path_tests}/{missing_option}.txt'
            os.system(cmd_missing)
            outfile = open(f"{path_curate}/CURATE_data.dat", "r")
            outlines = outfile.readlines()
            outfile.close()
            input_found,curate_valid = False,False
            for line in outlines:
                if missing_option == 'csv_name':
                    if "-  csv_name option set to tests/Robert_example.csv by the user" in line:
                        input_found = True
                elif missing_option == 'y':
                    if "-  y option set to Target_values by the user" in line:
                        input_found = True
                elif missing_option == 'names':
                    if "-  names option set to Name by the user" in line:
                        input_found = True
                if 'o  The Pearson heatmap was stored in CURATE/Pearson_heatmap.png' in line:
                    curate_valid = True
            assert input_found
            assert curate_valid

    elif test_job == "rfecv":
        _ = curate(**curate_kwargs)

        # check if variables are discarded right with RFECV
        db_final = pd.read_csv(f"{path_curate}/{csv_name.split('.csv')[0]}_CURATE.csv")
        assert 'rando4' not in db_final.columns

        accepted_vars = ['E_HOMO','V_Bur','dist', 'rando1', 'rando2', 'rando3']
        for var in accepted_vars:
            assert var in db_final.columns
